!=====================================================================
!
!               S p e c f e m 3 D  V e r s i o n  2 . 0
!               ---------------------------------------
!
!          Main authors: Dimitri Komatitsch and Jeroen Tromp
!    Princeton University, USA and University of Pau / CNRS / INRIA
! (c) Princeton University / California Institute of Technology and University of Pau / CNRS / INRIA
!                            April 2011
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
!=====================================================================
!
! United States and French Government Sponsorship Acknowledged.

  subroutine specfem3D()

  use specfem_par
  use project_tomo_grid_mod
  use dsm_coupling
  use adjoint_source
  use inversion_mod
  implicit none

!=============================================================================!
!  purpose : full wave form inversion based on                                !                                            !
!  specfem3D is a 3-D spectral-element solver for a local or regional model.  !
!  It uses a mesh generated by program generate_databases                     !
!                                                                             !
!                                                                             !
! this code is based on my old version of specfem thus is needed to update for!
!  the current version of specfem3D                                           !
!                                                                             !
!     Vadim Monteiller march 2015                                             !
!                                                                             !
!=============================================================================!


! ************** PROGRAM STARTS HERE **************

  ! force Flush-To-Zero if available to avoid very slow Gradual Underflow trapping
  call force_ftz()

! reads in parameters
  call initialize_simulation()

! reads in external mesh
  call read_mesh_databases()

! sets up reference element GLL points/weights/derivatives
  call setup_GLL_points()


! detects surfaces
  call detect_mesh_surfaces()


! reads topography & bathymetry
  call read_topography_bathymetry()


! prepares sources and receivers
  call setup_sources_receivers()

!! VM VM
  ! initialize simu
  SIMULATION_TYPE=3
  SAVE_FORWARD=.false.
  call simu_type()
  if (DSM_SOURCE) then
     COUPLING_WITH_DSM=.true.
     COUPLING_WITH_PLAN=.false.
  else if (PLAN_SOURCE) then
     COUPLING_WITH_DSM=.false.
     COUPLING_WITH_PLAN=.true.
  else
     COUPLING_WITH_DSM=.false.
     COUPLING_WITH_PLAN=.false.
  endif


  if (myrank==0) write(*,*) 'setup tomo grid'
  call setup_tomo_grid()
  !call setup_data()
  if (myrank == 0) write(*,*) 'set up dsm tractions', COUPLING_WITH_DSM
  call setup_DSM_tractions()

  !stop

  call prepare_timerun()
  call initialize_inversion()   !! reading inversion parameters
  call allocate_inv_wsk(nb_DSM_sources)
  call initial_model()


  !if (myrank == 0) write(*,*) 'set up dsm tractions'
  !call setup_DSM_tractions()


!! test projection
!  iter=0
!  call project_mode_in_tomo_grid_new()
!  call write_mode_in_disk()
!  call rho_vp_vs_2_kappa_mu()
!  iter=1
!  call project_mode_in_tomo_grid_new()
!  call write_mode_in_disk()
!  !call interpole_one_field()
!  stop
!!$

  !do iter=0,niter
  iter=0

  call compute_cost_gradient()
  call project_mode_in_tomo_grid_new()

  call addition_penalty(reg_par_1,reg_par_2,reg_type)

  !call add_penalty(sum_grad_alpha,alpha_grid,alpha_grid_prior,reg_wks,nx,ny,nz,reg_par_1,reg_par_2,reg_type,hx,hy,hz)
  !call compute_penalty_reg(alpha_grid,alpha_grid_prior,reg_wks,nx,ny,nz,penalty_value1,reg_par_1,reg_par_2,reg_type,hx,hy,hz)

  !call add_penalty(sum_grad_beta,beta_grid,beta_grid_prior,reg_wks,nx,ny,nz,reg_par_1,reg_par_2,reg_type,hx,hy,hz)
  !call compute_penalty_reg(beta_grid,beta_grid_prior,reg_wks,nx,ny,nz,penalty_value2,reg_par_1,reg_par_2,reg_type,hx,hy,hz)

  fit0=fitting_value
  !if (myrank==0)
  !write(*,*) 'penalty ', myrank, penalty_value1,penalty_value2,hx,hy,hz
  q0=fit0 + penalty_value1 + penalty_value2 + penalty_value3

  !call project_mode_in_tomo_grid()
  !call write_grad_in_disk()
  !call write_mode_in_disk()

  !call compute_descent_direction(nb_DSM_sources)
  !dfit0=deriv_adjust
  !qp0=dfit0
  step_length=1. !initial_step_length
  do iter=0,niter

     !if (myrank==0) write(*,*) 'global iter :', iter,q0,qp0

     call project_mode_in_tomo_grid_new()
     call write_grad_in_disk()
     call write_mode_in_disk()
     call write_sismo_in_disk(iter)

     if (.not.PERTURB_IN_TOMO_GRID) call save_current_model_SEM_in_memmory()
     call compute_descent_direction_1(nb_DSM_sources)
     qp0=deriv_adjust

     if (myrank==0) then
        call flush(IIOUT_INV)
        write(*,*)
        write(*,*) '------------------------------'
        write(*,'(a21,i5,3(f25.10))') 'optim : global iter :',  iter,q0,penalty_value1+penalty_value2,qp0
        write(IIOUT_INV,*) '------------------------------'
        write(IIOUT_INV,*) 'global iter :',  iter,q0,penalty_value1+penalty_value2,qp0
        write(*,*)
     endif
     !step_length=1. !initial_step_length
     flag_wolfe = .false.
     td=0.;tg=0.
     do iter_wolfe=1,maxiter_wolfe

       !write(*,*) 'befrnew ',myrank,iter_wolfe
       ! update model
       call compute_new_model()
       !write(*,*) 'afernew ',myrank
       !*project model in sem grid
       !call rho_vp_vs_2_kappa_mu()
       !write(*,*) 'afermu ',myrank,iter,iter_wolfe

       ! compute cost and gradient
       call compute_cost_gradient()
       call addition_penalty(reg_par_1,reg_par_2,reg_type)

       !call add_penalty(sum_grad_alpha,alpha_grid,alpha_grid_prior,reg_wks,nx,ny,nz,reg_par_1,reg_par_2,reg_type,hx,hy,hz)
       !call compute_penalty_reg(alpha_grid,alpha_grid_prior,reg_wks,nx,ny,nz,penalty_value1,reg_par_1,reg_par_2,reg_type,hx,hy,hz)

       !call add_penalty(sum_grad_beta,beta_grid,beta_grid_prior,reg_wks,nx,ny,nz,reg_par_1,reg_par_2,reg_type,hx,hy,hz)
       !call compute_penalty_reg(beta_grid,beta_grid_prior,reg_wks,nx,ny,nz,penalty_value2,reg_par_1,reg_par_2,reg_type,hx,hy,hz)

       !if (myrank==0) write(*,*) penalty_value1,penalty_value2
       !write(*,*) 'penalty ', myrank, penalty_value1,penalty_value2,hx,hy,hz
       !write(*,*) 'afergrad ',myrank,iter,iter_wolfe
       fit1=fitting_value
       qt=fit1+penalty_value1 + penalty_value2 + penalty_value3
       !write(*,*) myrank, qt,q0,step_length
       call compute_deriv()
       dfit1=deriv_adjust
       vqpt=dfit1
       qpt=(qt-q0)/step_length
       if (myrank==0) then
          call flush(IIOUT_INV)
          write(IIOUT_INV,*) 'try step :', step_length, iter_wolfe,qt,vqpt
          write(*,'(a18,f10.6,i4,3(f25.10))') 'optim : try step :', step_length, iter_wolfe,qt,vqpt,qpt
       endif
       ! wolfe test
       call wolfe_criteria()
       !write(*,*) 'aferwolfe ',myrank,iter_wolfe,maxiter_wolfe,iter,niter
       if (flag_wolfe) then
            q0=qt
            if (myrank==0) then
               call flush(IIOUT_INV)
               write(IIOUT_INV,*)  'step choosen : ', step_length
               write(*,'(a23,f25.10)')  'optim : step choosen : ', step_length
            endif
            exit
       endif

     enddo

     if (.not. flag_wolfe) exit

  enddo

  end subroutine specfem3D


  subroutine compute_cost_gradient()

    use specfem_par
    use specfem_par_elastic
    use inversion_mod
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling
    use plane_wave_mod
    implicit none
    integer i_DSM_source,ires,iadj
    character(len=5) name_data


    ! model projection in tomo grid
    !ires=1
    !call project_tomo_grid(kappastore,ires)
    !if (myrank == 0) write(*,*) 'End of kappastore projection ',iter
    !kappa_grid(:,:,:)=data_tomo(:,:,:)
    !call project_tomo_grid(mustore,ires)
    !if (myrank == 0) write(*,*) 'End of mustore projection ',iter
    !mu_grid(:,:,:)=data_tomo(:,:,:)
    !call project_tomo_grid(rho_vp,ires)
    !if (myrank == 0) write(*,*) 'End of rho_vp  projection ',iter
    !rho_grid(:,:,:)=data_tomo(:,:,:)

    !alpha_grid(:,:,:) = ( (kappa_grid(:,:,:) + (4./3.) * mu_grid(:,:,:)) /rho_grid(:,:,:) )

    !call project_tomo_grid(rho_vs,ires)
    !if (myrank == 0) write(*,*) 'End of rho_vs  projection ',iter
    !rho_grid(:,:,:)=data_tomo(:,:,:)
    !beta_grid(:,:,:) =  ( mu_grid(:,:,:) / rho_grid(:,:,:))
    !rho_grid(:,:,:)=rho_grid(:,:,:)/beta_grid(:,:,:)

    !name_data='alpha'
    !if (myrank==0) call write_mod(alpha_grid,iter,name_data)
    !name_data='beta_'
    !if (myrank ==0) call write_mod(beta_grid,iter,name_data)
    !name_data='_rho_'
    !if (myrank==0) call write_mod(rho_grid,iter,name_data)
    !call sync_all()
    !! ---

    isource_current=1
    sum_grad_alpha_kl=0._CUSTOM_REAL
    sum_grad_beta_kl=0._CUSTOM_REAL
    sum_grad_rho_kl=0._CUSTOM_REAL

    if (myrank == 0) write(*,*)
    SAVE_ADJOINT_KERNEL=.false.
    fitting_value=0.
    !write(*,*) 'in compute_cost_gradient() ', nb_DSM_sources
    do i_DSM_source=1,nb_DSM_sources

       ! direct simulation -----------------------------------
       SIMULATION_TYPE=1
       SAVE_FORWARD=.true.
       !COUPLING_WITH_DSM=.true.
       !COUPLING_WITH_PLAN=.false.
       if (DSM_SOURCE) then
          COUPLING_WITH_DSM=.true.
          COUPLING_WITH_PLAN=.false.
       else if (PLAN_SOURCE) then
          COUPLING_WITH_DSM=.false.
          COUPLING_WITH_PLAN=.true.
       else
          COUPLING_WITH_DSM=.false.
          COUPLING_WITH_PLAN=.false.
       endif

       if (myrank == 0) write(*,*) ' DIRECT SIMU',i_DSM_source,iter
       if (COUPLING_WITH_DSM) call open_DSM_tractions(i_DSM_source)
       if (COUPLING_WITH_PLAN) call read_plane_wave_par(myrank,DT,i_DSM_source)
       call re_init_simu(i_DSM_source)

       ! sets up and precomputes simulation arrays
       call re_prepare_timerun()
       ! steps through time iterations
       call iterate_time()
       ! saves last time frame and finishes kernel calculations
       call finalize_simulation()
       if (COUPLING_WITH_DSM) call close_DSM_tractions(i_DSM_source)
       call store_all_seismograms(i_DSM_source,iter,nrec_local,nb_DSM_sources,seismograms_d,NSTEP)

       ! end direct simulation ---------------------------

       if (myrank == 0) write(*,*) ' ADJOINT SIMU',i_DSM_source,iter
       ! adjoint simulation ------------------------------
       call define_adjoint_sources(i_DSM_source)!

       do iadj=1,nbadj
         call store_adj_src(i_DSM_source,iadj)
         call re_init_simu_adj(i_DSM_source)
         SIMULATION_TYPE=3
         SAVE_FORWARD=.false.
         COUPLING_WITH_DSM=.false.
         COUPLING_WITH_PLAN=.false.
         ! sets up and precomputes simulation arrays
         call re_prepare_timerun()
         ! steps through time iterations
         call iterate_time()
         ! saves last time frame and finishes kernel calculations
         call finalize_simulation()

         !ires=0

         !call project_tomo_grid(alpha_kl,ires)
         !grad_alpha(:,:,:,i_DSM_source)=data_tomo(:,:,:)
         sum_grad_alpha_kl(:,:,:,:) = sum_grad_alpha_kl(:,:,:,:) + scale_cost * alpha_kl(:,:,:,:)
         !name_data='alpha'
         !call write_kl(data_tomo,i_DSM_source,iter,name_data)

         !call project_tomo_grid(beta_kl,ires)
         !grad_beta(:,:,:,i_DSM_source)=data_tomo(:,:,:)
         sum_grad_beta_kl(:,:,:,:) = sum_grad_beta_kl(:,:,:,:) + scale_cost * beta_kl(:,:,:,:)
         !name_data='beta_'
         !call write_kl(data_tomo,i_DSM_source,iter,name_data)
         sum_grad_rho_kl(:,:,:,:) =  sum_grad_rho_kl(:,:,:,:) + scale_cost *  rhop_kl(:,:,:,:)
       enddo
    enddo

    ires=0
    !call project_tomo_grid_2(sum_grad_alpha_kl,sum_grad_beta_kl,ires)
    call interpole_one_field(sum_grad_alpha_kl)
    call project_one_field(ires)
    sum_grad_alpha(:,:,:)=data_tomo(:,:,:)

    call interpole_one_field(sum_grad_beta_kl)
    call project_one_field(ires)
    sum_grad_beta(:,:,:)=data_tomo(:,:,:)

    call interpole_one_field(sum_grad_rho_kl)
    call project_one_field(ires)
    sum_grad_rho(:,:,:)=data_tomo(:,:,:)

 end subroutine compute_cost_gradient


 subroutine initial_model()
    use specfem_par
    use specfem_par_elastic
    !use inversion_par
    use project_tomo_grid_mod
    use adjoint_source, only : READ_MODEL_IN_TOMO_GRID,file_model_vp,file_model_vs,file_model_rho,&
         file_model_vp_prior,file_model_vs_prior,file_model_rho_prior,reg_type
    !use dsm_coupling

    implicit none
    integer ires

  ! On lit le modele initial sur la grille tomo et on le projette sur SEM
  if (READ_MODEL_IN_TOMO_GRID) then

    if (myrank == 0) then

      open(27,file=trim(file_model_vp),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
      read(27,rec=1) alpha_grid
      close(27)
      write(*,*) trim(file_model_vp)

      open(27,file=trim(file_model_vs),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
      read(27,rec=1) beta_grid
      close(27)
      write(*,*)trim(file_model_vs)

      open(27,file=trim(file_model_rho),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
      read(27,rec=1) rho_grid
      close(27)
      write(*,*) trim(file_model_rho)

    endif
    !write(*,*) 'avant bcast ',myrank
    call mpi_bcast(alpha_grid,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call mpi_bcast(beta_grid,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call mpi_bcast(rho_grid,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    !write(*,*) 'apres bcast ', myrank
    ! Projection SEM->TOMO pour initialiser les tableaux
    ires=1
    !call project_tomo_grid(kappastore,ires)
    call interpole_one_field(kappastore) ! pas sur que ce soit utile maintenant
    call project_one_field(ires)         ! idem
    call rho_vp_vs_2_kappa_mu()

    ! it's better to read in the SEM grid directly
    call read_SEM_model()
  endif

  if (reg_type=='CO') then
     if (myrank == 0) then

        open(27,file=trim(file_model_vp_prior),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
        read(27,rec=1) alpha_grid_prior
        close(27)
        write(*,*) trim(file_model_vp_prior)

        open(27,file=trim(file_model_vs_prior),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
        read(27,rec=1) beta_grid_prior
        close(27)
        write(*,*)trim(file_model_vs_prior)

        open(27,file=trim(file_model_rho_prior),access='direct',recl=CUSTOM_REAL*nx*ny*nz)
        read(27,rec=1) rho_grid_prior
        close(27)
        write(*,*) trim(file_model_rho_prior)

     endif
     !write(*,*) 'avant bcast ',myrank
     call mpi_bcast(alpha_grid_prior,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
     call mpi_bcast(beta_grid_prior,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
     call mpi_bcast(rho_grid_prior,nx*ny*nz,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

  endif

 ! On utilise directement le DATABASE de SEM


 end subroutine initial_model




 subroutine rho_vp_vs_2_kappa_mu()
    use specfem_par
    use specfem_par_elastic
    !use inversion_par
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling

    implicit none


    ! projection de rho*vs
    data_tomo(:,:,:) = rho_grid(:,:,:)*beta_grid(:,:,:)
    call project_sem_interp(data_tomo,rho_vs)

    ! projection de rho*vp
    data_tomo(:,:,:) = rho_grid(:,:,:)*alpha_grid(:,:,:)
    call project_sem_interp(data_tomo,rho_vp)


    ! projection de mu
    mu_grid(:,:,:) = rho_grid(:,:,:)*beta_grid(:,:,:)*beta_grid(:,:,:)
    call project_sem_interp(mu_grid,mustore)

    ! projection de kappa
    kappa_grid(:,:,:) = rho_grid(:,:,:)*( (alpha_grid(:,:,:)**2) - FOUR_THIRDS*(beta_grid(:,:,:)**2) )
    call project_sem_interp(kappa_grid,kappastore)


 end subroutine rho_vp_vs_2_kappa_mu




 subroutine  project_mode_in_tomo_grid()

    use specfem_par
    use specfem_par_elastic
    use inversion_mod
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling


    implicit none
    integer ires


   if (myrank == 0) then
      write(*,*)
      write(*,*) 'porjection in tomo grid '
      write(*,*)
   endif
   ires=1

   call project_tomo_grid_4(kappastore,mustore,rho_vp,rho_vs,ires)
   if (myrank == 0) write(*,*) 'End of kappastore projection ',iter
   kappa_grid(:,:,:)=data_tomo1(:,:,:)

   !call project_tomo_grid(mustore,ires)
   if (myrank == 0) write(*,*) 'End of mustore projection ',iter
   mu_grid(:,:,:)=data_tomo2(:,:,:)

   !call project_tomo_grid(rho_vp,ires)
   if (myrank == 0) write(*,*) 'End of rho_vp  projection ',iter
   rho_grid(:,:,:)=data_tomo3(:,:,:)

   alpha_grid(:,:,:) = ( (kappa_grid(:,:,:) + (4./3.) * mu_grid(:,:,:)) /rho_grid(:,:,:) )

   !!

   !call project_tomo_grid(rho_vs,ires)
   if (myrank == 0) write(*,*) 'End of rho_vs  projection ',iter

   rho_grid(:,:,:)=data_tomo4(:,:,:)
   beta_grid(:,:,:) =  ( mu_grid(:,:,:) / rho_grid(:,:,:))
   rho_grid(:,:,:)=rho_grid(:,:,:)/beta_grid(:,:,:)

   if (myrank == 0) write(*,*)


 end subroutine project_mode_in_tomo_grid



 subroutine write_grad_in_disk()
    use specfem_par
    use specfem_par_elastic
    use inversion_mod
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling


    implicit none
    integer idsms
    character(len=5) name_data
    idsms=1
    if (myrank == 0) then
      !do idsms=1,nb_DSM_sources
         name_data='alpha'
         call write_kl(sum_grad_alpha,idsms,iter,name_data,nb_DSM_sources)

         name_data='beta_'
         call write_kl(sum_grad_beta,idsms,iter,name_data,nb_DSM_sources)

          name_data='_rho_'
         call write_kl(sum_grad_rho,idsms,iter,name_data,nb_DSM_sources)
       !enddo
     endif
     call sync_all()

 end subroutine write_grad_in_disk



 subroutine write_mode_in_disk()
    use specfem_par
    use specfem_par_elastic
    use inversion_mod
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling


    implicit none
    character(len=5) name_data


    name_data='alpha'
    if (myrank==0) call write_mod(alpha_grid,iter,name_data)
    name_data='beta_'
    if (myrank ==0) call write_mod(beta_grid,iter,name_data)
    name_data='_rho_'
    if (myrank==0) call write_mod(rho_grid,iter,name_data)
    call sync_all()
    call write_SEM_model()

 end subroutine write_mode_in_disk


 subroutine write_SEM_model()
  use specfem_par
  use specfem_par_elastic
  implicit none
  open(27,file=trim(SEM_FILE_OUTPUT_MODEL),form='unformatted')

  write(27) kappastore
  write(27) mustore
  write(27) rho_vp
  write(27) rho_vs
  close(27)



 end subroutine write_SEM_model



 subroutine read_SEM_model()
  use specfem_par
  use specfem_par_elastic
  use inversion_mod

  implicit none
  integer i,j,k,ispec,iglob
  real(kind=CUSTOM_REAL) weight, jacobianl

  open(27,file=trim(SEM_FILE_OUTPUT_MODEL),form='unformatted')

  read(27) kappastore
  read(27) mustore
  read(27) rho_vp
  read(27) rho_vs
  close(27)

  beta_in_SEM_mesh(:,:,:,:) =  mustore(:,:,:,:) / rho_vs(:,:,:,:)
  rho_in_SEM_mesh(:,:,:,:) = rho_vs(:,:,:,:) /  beta_in_SEM_mesh(:,:,:,:)

  ! mass matrix
  rmass(:) = 0._CUSTOM_REAL
  do ispec=1,nspec_ab
     do k=1,NGLLZ
        do j=1,NGLLY
           do i=1,NGLLX
              iglob = ibool(i,j,k,ispec)
              weight = wxgll(i)*wygll(j)*wzgll(k)
              jacobianl = jacobian(i,j,k,ispec)
              rmass(iglob) = rmass(iglob) + &
                   jacobianl * weight * rho_in_SEM_mesh(i,j,k,ispec)
           enddo
        enddo
     enddo
  enddo

end subroutine read_SEM_model


 subroutine  project_mode_in_tomo_grid_new()

    use specfem_par
    use specfem_par_elastic
    use inversion_mod
    use project_tomo_grid_mod
    use adjoint_source
    use dsm_coupling


    implicit none
    integer ires
    integer i,j,k

   if (myrank == 0) then
      write(*,*)
      write(*,*) 'projection in tomo grid '
      write(*,*)
   endif
   ires=1

   !call project_tomo_grid_4(kappastore,mustore,rho_vp,rho_vs,ires)
   call interpole_one_field(kappastore)
!!$   if (myrank == 0) write(*,*) 'End of kappastore interpolation ',iter
   call project_one_field(ires)
   if (myrank == 0) write(*,*) 'End of kappastore projection ',iter
   kappa_grid(:,:,:)=data_tomo(:,:,:)

   !call project_tomo_grid(mustore,ires)
   call interpole_one_field(mustore)
   call project_one_field(ires)
   if (myrank == 0) write(*,*) 'End of mustore projection ',iter
   mu_grid(:,:,:)=data_tomo(:,:,:)

   !call project_tomo_grid(rho_vp,ires)
   call interpole_one_field(rho_vp)
   call project_one_field(ires)
   if (myrank == 0) write(*,*) 'End of rho_vp projection ',iter
   rho_grid(:,:,:)=data_tomo(:,:,:)

   alpha_grid(:,:,:) = ( (kappa_grid(:,:,:) + (4./3.) * mu_grid(:,:,:)) /rho_grid(:,:,:) )
!!$   !! debgug
!!$   if (iter==0) then
!!$   do k=1,nz
!!$      do j=1,ny
!!$         do i=1,nx
!!$            alpha_grid(i,j,k)=i+(j-1)*nx + (k-1)*nx*ny
!!$            if (k==1 .and. myrank==0) write(*,*) i,j,alpha_grid(i,j,k)
!!$         enddo
!!$      enddo
!!$   enddo
!!$   if (myrank==0) then
!!$      open(666,file='verif_alpha',access='direct',recl=4*nx*ny*nz)
!!$      write(666,rec=1) alpha_grid
!!$      close(666)
!!$   endif
!!$   endif
   call interpole_one_field(rho_vs)
   call project_one_field(ires)
   !call project_tomo_grid(rho_vs,ires)
   if (myrank == 0) write(*,*) 'End of rho_vs  projection ',iter

   rho_grid(:,:,:)=data_tomo(:,:,:)
   beta_grid(:,:,:) =  ( mu_grid(:,:,:) / rho_grid(:,:,:))
   rho_grid(:,:,:)=rho_grid(:,:,:)/beta_grid(:,:,:)

   if (myrank == 0) write(*,*)


 end subroutine project_mode_in_tomo_grid_new


subroutine simu_type()

  use specfem_par
  implicit none
  include 'mpif.h'
  include 'precision.h'

  integer i,source_type_0,ier
  DSM_SOURCE=.false.
  PLAN_SOURCE=.false.

  if (myrank==0) then
     open(27,file='inversion.par')
     read(27,*) i
     read(27,*) source_type_0
     close(27)

     if (source_type_0==0) then
        DSM_SOURCE=.false.
        PLAN_SOURCE=.false.
     endif
     if (source_type_0==1) then
        DSM_SOURCE=.true.
        PLAN_SOURCE=.false.
     endif
     if (source_type_0==2) then
        DSM_SOURCE=.false.
        PLAN_SOURCE=.true.
     endif
  endif

  call mpi_bcast(DSM_SOURCE, 1 ,MPI_LOGICAL,0,MPI_COMM_WORLD,ier)
  call mpi_bcast(PLAN_SOURCE, 1 ,MPI_LOGICAL,0,MPI_COMM_WORLD,ier)

end subroutine simu_type
